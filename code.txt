
/Users/matiaskochman/dev/personal/tests/post_comments/.env

DB_HOST=localhost
DB_PORT=5555
DB_USER=my_user
DB_PASSWORD=my_password
DB_NAME=my_database


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/src/swagger.config.ts

// src/swagger.config.ts

const swaggerOptions = {
  openapi: "3.0.0",
  info: {
    title: "Post Comments API",
    version: "1.0.0",
    description: "API para gestionar posts y comentarios",
  },
  servers: [
    {
      url: "http://localhost:3000",
      description: "Servidor local",
    },
  ],
  components: {
    schemas: {
      Post: {
        type: "object",
        properties: {
          id: { type: "integer", description: "ID único del post" },
          title: { type: "string", description: "Título del post" },
          body: { type: "string", description: "Contenido del post" },
          image: {
            type: "string",
            nullable: true,
            description: "URL de la imagen del post",
          },
          userId: {
            type: "integer",
            description: "ID del usuario que creó el post",
          },
          comments: {
            type: "array",
            items: { $ref: "#/components/schemas/Comment" },
            description: "Lista de comentarios asociados al post",
          },
        },
        required: ["id", "title", "body", "userId"],
      },
      Comment: {
        type: "object",
        properties: {
          id: { type: "integer", description: "ID único del comentario" },
          body: { type: "string", description: "Contenido del comentario" },
          name: {
            type: "string",
            description: "Nombre del autor del comentario",
          },
          email: {
            type: "string",
            description: "Email del autor del comentario",
          },
          postId: {
            type: "integer",
            description: "ID del post al que pertenece el comentario",
          },
        },
        required: ["id", "body", "name", "email", "postId"],
      },
    },
  },
};

export default swaggerOptions;


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/dist/app.js

"use strict";
// src/app.ts
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const express_1 = __importDefault(require("express"));
const post_routes_1 = __importDefault(require("./routes/post.routes"));
const comment_routes_1 = __importDefault(require("./routes/comment.routes"));
const test_routes_1 = __importDefault(require("./routes/test.routes")); // Importar la ruta de prueba
const swagger_ui_express_1 = __importDefault(require("swagger-ui-express"));
const swagger_jsdoc_1 = __importDefault(require("swagger-jsdoc"));
const swagger_config_1 = __importDefault(require("./swagger.config"));
const errorHandler_1 = require("./middleware/errorHandler");
const app = (0, express_1.default)();
app.use(express_1.default.json());
// Configuración de Swagger
const swaggerSpec = (0, swagger_jsdoc_1.default)({
    definition: swagger_config_1.default,
    apis: ["src/routes/*.ts"],
});
app.use("/api-docs", swagger_ui_express_1.default.serve, swagger_ui_express_1.default.setup(swaggerSpec));
// Rutas de la API
app.use("/api/posts", post_routes_1.default);
app.use("/api/comments", comment_routes_1.default);
app.use("/api/test", test_routes_1.default); // Usar la ruta de prueba
// Middleware de manejo de errores
app.use(errorHandler_1.errorHandler);
exports.default = app;


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/dist/controllers/comment.controller.js

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.moveComment = exports.createComment = void 0;
const comment_service_1 = require("../services/comment.service");
const commentService = new comment_service_1.CommentService();
/**
 * Controlador para crear un comentario asociado a un post existente.
 */
const createComment = async (req, res, next) => {
    try {
        const { body, name, email, postId } = req.body;
        const postIdNumber = Number(postId); // Conversion explícita a número
        const savedComment = await commentService.createComment({
            body,
            name,
            email,
            postId: postIdNumber,
        });
        res.status(201).json(savedComment);
    }
    catch (error) {
        next(error);
    }
};
exports.createComment = createComment;
/**
 * Controlador para mover un comentario de un post a otro.
 */
const moveComment = async (req, res, next) => {
    try {
        const { commentId, newPostId } = req.body;
        const commentIdNumber = Number(commentId); // Conversion explícita a número
        const newPostIdNumber = Number(newPostId); // Conversion explícita a número
        const movedComment = await commentService.moveComment({
            commentId: commentIdNumber,
            newPostId: newPostIdNumber,
        });
        res.status(200).json({
            message: "Comentario movido exitosamente",
            comment: movedComment,
        });
    }
    catch (error) {
        next(error);
    }
};
exports.moveComment = moveComment;


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/dist/controllers/post.controller.js

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.restorePost = exports.softDeletePost = exports.getCommentsByPostId = exports.getPostById = exports.createPost = exports.getAllPosts = void 0;
const post_service_1 = require("../services/post.service");
const postService = new post_service_1.PostService();
/**
 * Obtiene todos los posts con sus comentarios.
 */
const getAllPosts = async (req, res, next) => {
    try {
        const posts = await postService.getAllPosts();
        res.json(posts);
    }
    catch (error) {
        next(error);
    }
};
exports.getAllPosts = getAllPosts;
/**
 * Crea un nuevo post.
 */
const createPost = async (req, res, next) => {
    try {
        const { title, body, image, userId } = req.body;
        const savedPost = await postService.createPost({
            title,
            body,
            image,
            userId,
        });
        res.status(201).json(savedPost);
    }
    catch (error) {
        next(error);
    }
};
exports.createPost = createPost;
/**
 * Obtiene un post por su ID, incluyendo sus comentarios.
 */
const getPostById = async (req, res, next) => {
    try {
        const { id } = req.params;
        const post = await postService.getPostById(Number(id));
        res.json(post);
    }
    catch (error) {
        next(error);
    }
};
exports.getPostById = getPostById;
/**
 * Obtiene todos los comentarios de un post específico.
 */
const getCommentsByPostId = async (req, res, next) => {
    try {
        const { post_id } = req.params;
        const comments = await postService.getCommentsByPostId(Number(post_id));
        res.json(comments);
    }
    catch (error) {
        next(error);
    }
};
exports.getCommentsByPostId = getCommentsByPostId;
/**
 * Elimina lógicamente un post por su ID.
 */
const softDeletePost = async (req, res, next) => {
    try {
        const { id } = req.params;
        await postService.deletePost(Number(id));
        res.status(200).json({ message: "Post eliminado correctamente" });
    }
    catch (error) {
        next(error);
    }
};
exports.softDeletePost = softDeletePost;
/**
 * Restaura un post eliminado lógicamente.
 */
const restorePost = async (req, res, next) => {
    try {
        const { id } = req.params;
        await postService.restorePost(Number(id));
        res.status(200).json({ message: "Post restaurado correctamente" });
    }
    catch (error) {
        next(error);
    }
};
exports.restorePost = restorePost;


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/dist/dtos/CreateCommentDTO.js

"use strict";
// src/dtos/CreateCommentDTO.ts
var __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CreateCommentDTO = void 0;
const class_validator_1 = require("class-validator");
let CreateCommentDTO = (() => {
    var _a;
    let _body_decorators;
    let _body_initializers = [];
    let _body_extraInitializers = [];
    let _name_decorators;
    let _name_initializers = [];
    let _name_extraInitializers = [];
    let _email_decorators;
    let _email_initializers = [];
    let _email_extraInitializers = [];
    let _postId_decorators;
    let _postId_initializers = [];
    let _postId_extraInitializers = [];
    return _a = class CreateCommentDTO {
            constructor() {
                this.body = __runInitializers(this, _body_initializers, void 0);
                this.name = (__runInitializers(this, _body_extraInitializers), __runInitializers(this, _name_initializers, void 0));
                this.email = (__runInitializers(this, _name_extraInitializers), __runInitializers(this, _email_initializers, void 0));
                this.postId = (__runInitializers(this, _email_extraInitializers), __runInitializers(this, _postId_initializers, void 0));
                __runInitializers(this, _postId_extraInitializers);
            }
        },
        (() => {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
            _body_decorators = [(0, class_validator_1.IsString)(), (0, class_validator_1.IsNotEmpty)()];
            _name_decorators = [(0, class_validator_1.IsString)(), (0, class_validator_1.IsNotEmpty)()];
            _email_decorators = [(0, class_validator_1.IsEmail)()];
            _postId_decorators = [(0, class_validator_1.IsInt)()];
            __esDecorate(null, null, _body_decorators, { kind: "field", name: "body", static: false, private: false, access: { has: obj => "body" in obj, get: obj => obj.body, set: (obj, value) => { obj.body = value; } }, metadata: _metadata }, _body_initializers, _body_extraInitializers);
            __esDecorate(null, null, _name_decorators, { kind: "field", name: "name", static: false, private: false, access: { has: obj => "name" in obj, get: obj => obj.name, set: (obj, value) => { obj.name = value; } }, metadata: _metadata }, _name_initializers, _name_extraInitializers);
            __esDecorate(null, null, _email_decorators, { kind: "field", name: "email", static: false, private: false, access: { has: obj => "email" in obj, get: obj => obj.email, set: (obj, value) => { obj.email = value; } }, metadata: _metadata }, _email_initializers, _email_extraInitializers);
            __esDecorate(null, null, _postId_decorators, { kind: "field", name: "postId", static: false, private: false, access: { has: obj => "postId" in obj, get: obj => obj.postId, set: (obj, value) => { obj.postId = value; } }, metadata: _metadata }, _postId_initializers, _postId_extraInitializers);
            if (_metadata) Object.defineProperty(_a, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        })(),
        _a;
})();
exports.CreateCommentDTO = CreateCommentDTO;


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/dist/dtos/CreatePostDTO.js

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/dist/dtos/comment.dtos.js

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/dist/entities/Comment.js

"use strict";
// src/entities/Comment.ts
var __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __setFunctionName = (this && this.__setFunctionName) || function (f, name, prefix) {
    if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
    return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Comment = void 0;
const typeorm_1 = require("typeorm");
const Post_1 = require("./Post");
let Comment = (() => {
    let _classDecorators = [(0, typeorm_1.Entity)()];
    let _classDescriptor;
    let _classExtraInitializers = [];
    let _classThis;
    let _id_decorators;
    let _id_initializers = [];
    let _id_extraInitializers = [];
    let _body_decorators;
    let _body_initializers = [];
    let _body_extraInitializers = [];
    let _name_decorators;
    let _name_initializers = [];
    let _name_extraInitializers = [];
    let _email_decorators;
    let _email_initializers = [];
    let _email_extraInitializers = [];
    let _postId_decorators;
    let _postId_initializers = [];
    let _postId_extraInitializers = [];
    let _post_decorators;
    let _post_initializers = [];
    let _post_extraInitializers = [];
    var Comment = _classThis = class {
        constructor() {
            this.id = __runInitializers(this, _id_initializers, void 0);
            this.body = (__runInitializers(this, _id_extraInitializers), __runInitializers(this, _body_initializers, void 0));
            this.name = (__runInitializers(this, _body_extraInitializers), __runInitializers(this, _name_initializers, void 0));
            this.email = (__runInitializers(this, _name_extraInitializers), __runInitializers(this, _email_initializers, void 0));
            this.postId = (__runInitializers(this, _email_extraInitializers), __runInitializers(this, _postId_initializers, void 0));
            this.post = (__runInitializers(this, _postId_extraInitializers), __runInitializers(this, _post_initializers, void 0));
            __runInitializers(this, _post_extraInitializers);
        }
    };
    __setFunctionName(_classThis, "Comment");
    (() => {
        const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
        _id_decorators = [(0, typeorm_1.PrimaryGeneratedColumn)()];
        _body_decorators = [(0, typeorm_1.Column)({ type: "text" })];
        _name_decorators = [(0, typeorm_1.Column)({ type: "varchar", length: 255 })];
        _email_decorators = [(0, typeorm_1.Column)({ type: "varchar", length: 255 })];
        _postId_decorators = [(0, typeorm_1.Column)({ type: "int" })];
        _post_decorators = [(0, typeorm_1.ManyToOne)(() => Post_1.Post, (post) => post.comments, { onDelete: "CASCADE" }), (0, typeorm_1.JoinColumn)({ name: "postId" })];
        __esDecorate(null, null, _id_decorators, { kind: "field", name: "id", static: false, private: false, access: { has: obj => "id" in obj, get: obj => obj.id, set: (obj, value) => { obj.id = value; } }, metadata: _metadata }, _id_initializers, _id_extraInitializers);
        __esDecorate(null, null, _body_decorators, { kind: "field", name: "body", static: false, private: false, access: { has: obj => "body" in obj, get: obj => obj.body, set: (obj, value) => { obj.body = value; } }, metadata: _metadata }, _body_initializers, _body_extraInitializers);
        __esDecorate(null, null, _name_decorators, { kind: "field", name: "name", static: false, private: false, access: { has: obj => "name" in obj, get: obj => obj.name, set: (obj, value) => { obj.name = value; } }, metadata: _metadata }, _name_initializers, _name_extraInitializers);
        __esDecorate(null, null, _email_decorators, { kind: "field", name: "email", static: false, private: false, access: { has: obj => "email" in obj, get: obj => obj.email, set: (obj, value) => { obj.email = value; } }, metadata: _metadata }, _email_initializers, _email_extraInitializers);
        __esDecorate(null, null, _postId_decorators, { kind: "field", name: "postId", static: false, private: false, access: { has: obj => "postId" in obj, get: obj => obj.postId, set: (obj, value) => { obj.postId = value; } }, metadata: _metadata }, _postId_initializers, _postId_extraInitializers);
        __esDecorate(null, null, _post_decorators, { kind: "field", name: "post", static: false, private: false, access: { has: obj => "post" in obj, get: obj => obj.post, set: (obj, value) => { obj.post = value; } }, metadata: _metadata }, _post_initializers, _post_extraInitializers);
        __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
        Comment = _classThis = _classDescriptor.value;
        if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        __runInitializers(_classThis, _classExtraInitializers);
    })();
    return Comment = _classThis;
})();
exports.Comment = Comment;


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/dist/entities/Post.js

"use strict";
// src/entities/Post.ts
var __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __setFunctionName = (this && this.__setFunctionName) || function (f, name, prefix) {
    if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
    return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Post = void 0;
const typeorm_1 = require("typeorm");
const Comment_1 = require("./Comment");
let Post = (() => {
    let _classDecorators = [(0, typeorm_1.Entity)()];
    let _classDescriptor;
    let _classExtraInitializers = [];
    let _classThis;
    let _id_decorators;
    let _id_initializers = [];
    let _id_extraInitializers = [];
    let _title_decorators;
    let _title_initializers = [];
    let _title_extraInitializers = [];
    let _body_decorators;
    let _body_initializers = [];
    let _body_extraInitializers = [];
    let _image_decorators;
    let _image_initializers = [];
    let _image_extraInitializers = [];
    let _userId_decorators;
    let _userId_initializers = [];
    let _userId_extraInitializers = [];
    let _comments_decorators;
    let _comments_initializers = [];
    let _comments_extraInitializers = [];
    let _deletedAt_decorators;
    let _deletedAt_initializers = [];
    let _deletedAt_extraInitializers = [];
    var Post = _classThis = class {
        constructor() {
            this.id = __runInitializers(this, _id_initializers, void 0);
            this.title = (__runInitializers(this, _id_extraInitializers), __runInitializers(this, _title_initializers, void 0));
            this.body = (__runInitializers(this, _title_extraInitializers), __runInitializers(this, _body_initializers, void 0));
            this.image = (__runInitializers(this, _body_extraInitializers), __runInitializers(this, _image_initializers, void 0));
            this.userId = (__runInitializers(this, _image_extraInitializers), __runInitializers(this, _userId_initializers, void 0));
            this.comments = (__runInitializers(this, _userId_extraInitializers), __runInitializers(this, _comments_initializers, void 0));
            this.deletedAt = (__runInitializers(this, _comments_extraInitializers), __runInitializers(this, _deletedAt_initializers, void 0)); // Maneja soft delete automáticamente
            __runInitializers(this, _deletedAt_extraInitializers);
        }
    };
    __setFunctionName(_classThis, "Post");
    (() => {
        const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
        _id_decorators = [(0, typeorm_1.PrimaryGeneratedColumn)()];
        _title_decorators = [(0, typeorm_1.Column)({ type: "varchar" })];
        _body_decorators = [(0, typeorm_1.Column)({ type: "text", nullable: true })];
        _image_decorators = [(0, typeorm_1.Column)({ type: "varchar", nullable: true })];
        _userId_decorators = [(0, typeorm_1.Column)({ type: "int" })];
        _comments_decorators = [(0, typeorm_1.OneToMany)(() => Comment_1.Comment, (comment) => comment.post, { cascade: true })];
        _deletedAt_decorators = [(0, typeorm_1.DeleteDateColumn)()];
        __esDecorate(null, null, _id_decorators, { kind: "field", name: "id", static: false, private: false, access: { has: obj => "id" in obj, get: obj => obj.id, set: (obj, value) => { obj.id = value; } }, metadata: _metadata }, _id_initializers, _id_extraInitializers);
        __esDecorate(null, null, _title_decorators, { kind: "field", name: "title", static: false, private: false, access: { has: obj => "title" in obj, get: obj => obj.title, set: (obj, value) => { obj.title = value; } }, metadata: _metadata }, _title_initializers, _title_extraInitializers);
        __esDecorate(null, null, _body_decorators, { kind: "field", name: "body", static: false, private: false, access: { has: obj => "body" in obj, get: obj => obj.body, set: (obj, value) => { obj.body = value; } }, metadata: _metadata }, _body_initializers, _body_extraInitializers);
        __esDecorate(null, null, _image_decorators, { kind: "field", name: "image", static: false, private: false, access: { has: obj => "image" in obj, get: obj => obj.image, set: (obj, value) => { obj.image = value; } }, metadata: _metadata }, _image_initializers, _image_extraInitializers);
        __esDecorate(null, null, _userId_decorators, { kind: "field", name: "userId", static: false, private: false, access: { has: obj => "userId" in obj, get: obj => obj.userId, set: (obj, value) => { obj.userId = value; } }, metadata: _metadata }, _userId_initializers, _userId_extraInitializers);
        __esDecorate(null, null, _comments_decorators, { kind: "field", name: "comments", static: false, private: false, access: { has: obj => "comments" in obj, get: obj => obj.comments, set: (obj, value) => { obj.comments = value; } }, metadata: _metadata }, _comments_initializers, _comments_extraInitializers);
        __esDecorate(null, null, _deletedAt_decorators, { kind: "field", name: "deletedAt", static: false, private: false, access: { has: obj => "deletedAt" in obj, get: obj => obj.deletedAt, set: (obj, value) => { obj.deletedAt = value; } }, metadata: _metadata }, _deletedAt_initializers, _deletedAt_extraInitializers);
        __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
        Post = _classThis = _classDescriptor.value;
        if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        __runInitializers(_classThis, _classExtraInitializers);
    })();
    return Post = _classThis;
})();
exports.Post = Post;


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/dist/entities/index.js

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
// src/entities/index.ts
__exportStar(require("./Post"), exports);
__exportStar(require("./Comment"), exports);


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/dist/index.js

"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// src/index.ts
const dotenv_1 = __importDefault(require("dotenv"));
// Cargar variables de entorno desde .env
dotenv_1.default.config();
require("reflect-metadata");
const ormconfig_1 = require("./ormconfig");
const app_1 = __importDefault(require("./app"));
const PORT = 3000;
ormconfig_1.dataSource
    .initialize()
    .then(() => {
    console.log("Data Source has been initialized!");
    app_1.default.listen(PORT, () => console.log(`Server is running on http://localhost:${PORT}`));
})
    .catch((err) => {
    console.error("Error during Data Source initialization", err);
});


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/dist/middleware/errorHandler.js

"use strict";
// src/middleware/errorHandler.ts
Object.defineProperty(exports, "__esModule", { value: true });
exports.errorHandler = void 0;
/**
 * Middleware de manejo de errores.
 * Captura cualquier error que ocurra en las rutas y envía una respuesta estandarizada.
 */
const errorHandler = (err, req, res, next) => {
    console.error(err);
    const statusCode = err.status || err.statusCode || 500;
    const message = err.message || "Internal Server Error";
    res.status(statusCode).json({
        message,
    });
};
exports.errorHandler = errorHandler;


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/dist/migrations/AddPostIdToComment.js

"use strict";
// import {
//   MigrationInterface,
//   QueryRunner,
//   TableColumn,
//   TableForeignKey,
// } from "typeorm";
// export class AddPostIdToComment1682579463000 implements MigrationInterface {
//   public async up(queryRunner: QueryRunner): Promise<void> {
//     // Añadir la columna postId a la tabla comment
//     await queryRunner.addColumn(
//       "comment",
//       new TableColumn({
//         name: "postId",
//         type: "int",
//         isNullable: false, // Ajusta según tus necesidades
//       })
//     );
//     // Crear la clave foránea hacia la tabla post
//     await queryRunner.createForeignKey(
//       "comment",
//       new TableForeignKey({
//         columnNames: ["postId"],
//         referencedColumnNames: ["id"],
//         referencedTableName: "post",
//         onDelete: "CASCADE", // Ajusta según tus necesidades
//       })
//     );
//   }
//   public async down(queryRunner: QueryRunner): Promise<void> {
//     // Obtener la tabla comment
//     const table = await queryRunner.getTable("comment");
//     if (!table) {
//       throw new Error("La tabla 'comment' no existe");
//     }
//     // Encontrar la clave foránea creada
//     const foreignKey = table.foreignKeys.find(
//       (fk) => fk.columnNames.indexOf("postId") !== -1
//     );
//     if (foreignKey) {
//       await queryRunner.dropForeignKey("comment", foreignKey);
//     }
//     // Eliminar la columna postId
//     await queryRunner.dropColumn("comment", "postId");
//   }
// }


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/dist/ormconfig.js

"use strict";
// src/ormconfig.ts
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.testDataSource = exports.dataSource = void 0;
const typeorm_1 = require("typeorm");
const Post_1 = require("./entities/Post");
const Comment_1 = require("./entities/Comment");
const dotenv_1 = __importDefault(require("dotenv"));
dotenv_1.default.config();
// Instancia para Desarrollo y Producción
exports.dataSource = new typeorm_1.DataSource({
    type: "mysql",
    host: process.env.DB_HOST || "localhost",
    port: parseInt(process.env.DB_PORT || "3306"),
    username: process.env.DB_USER || "root",
    password: process.env.DB_PASSWORD || "password",
    database: process.env.DB_NAME || "my_database",
    synchronize: false, // Debe ser false para usar migraciones
    logging: false,
    entities: [Post_1.Post, Comment_1.Comment],
    migrations: ["src/migrations/*.ts"],
    subscribers: [],
});
// Instancia para Pruebas
exports.testDataSource = new typeorm_1.DataSource({
    type: "sqlite",
    database: ":memory:",
    dropSchema: true,
    entities: [Post_1.Post, Comment_1.Comment],
    synchronize: true, // Sincronizar el esquema para pruebas
    logging: false,
});


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/dist/routes/comment.routes.js

"use strict";
// src/routes/comment.routes.ts
Object.defineProperty(exports, "__esModule", { value: true });
const express_1 = require("express");
const comment_controller_1 = require("../controllers/comment.controller");
const router = (0, express_1.Router)();
/**
 * @swagger
 * /api/comments:
 *   post:
 *     summary: Crea un nuevo comentario
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               body:
 *                 type: string
 *               name:
 *                 type: string
 *               email:
 *                 type: string
 *               postId:
 *                 type: integer
 *             required:
 *               - body
 *               - name
 *               - email
 *               - postId
 *     responses:
 *       201:
 *         description: Comentario creado
 *       400:
 *         description: Faltan campos obligatorios
 *       404:
 *         description: Post no encontrado o eliminado
 *       500:
 *         description: Error interno del servidor
 */
router.post("/", comment_controller_1.createComment);
/**
 * @swagger
 * /api/comments/move:
 *   put:
 *     summary: Mueve un comentario de un post a otro
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               commentId:
 *                 type: integer
 *                 description: ID del comentario a mover
 *               newPostId:
 *                 type: integer
 *                 description: ID del nuevo post al que se moverá el comentario
 *             required:
 *               - commentId
 *               - newPostId
 *     responses:
 *       200:
 *         description: Comentario movido exitosamente
 *       400:
 *         description: IDs inválidos
 *       404:
 *         description: Comentario o nuevo post no encontrado
 *       500:
 *         description: Error interno del servidor
 */
router.put("/move", comment_controller_1.moveComment);
exports.default = router;


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/dist/routes/post.routes.js

"use strict";
// src/routes/post.routes.ts
Object.defineProperty(exports, "__esModule", { value: true });
const express_1 = require("express");
const post_controller_1 = require("../controllers/post.controller");
const router = (0, express_1.Router)();
/**
 * @swagger
 * /api/posts:
 *   get:
 *     summary: Obtiene todos los posts
 *     responses:
 *       200:
 *         description: Lista de posts
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 $ref: "#/components/schemas/Post"
 */
router.get("/", post_controller_1.getAllPosts);
/**
 * @swagger
 * /api/posts:
 *   post:
 *     summary: Crea un nuevo post
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               title:
 *                 type: string
 *               body:
 *                 type: string
 *               image:
 *                 type: string
 *               userId:
 *                 type: integer
 *             required:
 *               - title
 *               - body
 *               - userId
 *     responses:
 *       201:
 *         description: Post creado
 *       400:
 *         description: Faltan campos obligatorios
 *       500:
 *         description: Error interno del servidor
 */
router.post("/", post_controller_1.createPost);
/**
 * @swagger
 * /api/posts/{id}:
 *   get:
 *     summary: Obtiene un post por ID
 *     parameters:
 *       - name: id
 *         in: path
 *         required: true
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: Post encontrado
 *         content:
 *           application/json:
 *             schema:
 *               $ref: "#/components/schemas/Post"
 *       400:
 *         description: ID inválido
 *       404:
 *         description: Post no encontrado
 *       500:
 *         description: Error interno del servidor
 */
router.get("/:id", post_controller_1.getPostById);
/**
 * @swagger
 * /api/posts/{post_id}/comments:
 *   get:
 *     summary: Obtiene todos los comentarios de un post específico
 *     parameters:
 *       - name: post_id
 *         in: path
 *         required: true
 *         description: ID del post para obtener sus comentarios
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: Lista de comentarios del post
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 $ref: "#/components/schemas/Comment"
 *       400:
 *         description: ID de post inválido
 *       404:
 *         description: Post no encontrado
 *       500:
 *         description: Error interno del servidor
 */
router.get("/:post_id/comments", post_controller_1.getCommentsByPostId);
/**
 * @swagger
 * /api/posts/{id}:
 *   delete:
 *     summary: Elimina lógicamente un post por su ID
 *     parameters:
 *       - name: id
 *         in: path
 *         required: true
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: Post eliminado correctamente
 *       400:
 *         description: ID inválido
 *       404:
 *         description: Post no encontrado
 *       500:
 *         description: Error interno del servidor
 */
router.delete("/:id", post_controller_1.softDeletePost);
/**
 * @swagger
 * /api/posts/{id}/restore:
 *   patch:
 *     summary: Restaura un post eliminado lógicamente
 *     parameters:
 *       - name: id
 *         in: path
 *         required: true
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: Post restaurado correctamente
 *       400:
 *         description: ID inválido
 *       404:
 *         description: Post no encontrado o no está eliminado
 *       500:
 *         description: Error interno del servidor
 */
router.patch("/:id/restore", post_controller_1.restorePost);
exports.default = router;


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/dist/routes/test.routes.js

"use strict";
// src/routes/test.routes.ts
Object.defineProperty(exports, "__esModule", { value: true });
const express_1 = require("express");
const router = (0, express_1.Router)();
/**
 * Ruta de prueba para generar un error.
 */
router.get("/error", (req, res) => {
    throw new Error("This is a test error.");
});
exports.default = router;


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/dist/services/comment.service.js

"use strict";
// src/services/comment.service.ts
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommentService = void 0;
const Comment_1 = require("../entities/Comment");
const ormconfig_1 = require("../ormconfig");
const Post_1 = require("../entities/Post");
class CommentService {
    constructor() {
        const isTest = process.env.NODE_ENV === "test";
        this.commentRepository = isTest
            ? ormconfig_1.testDataSource.getRepository(Comment_1.Comment)
            : ormconfig_1.dataSource.getRepository(Comment_1.Comment);
        this.postRepository = isTest
            ? ormconfig_1.testDataSource.getRepository(Post_1.Post)
            : ormconfig_1.dataSource.getRepository(Post_1.Post);
    }
    // Crear un nuevo comentario
    async createComment(data) {
        const { body, name, email, postId } = data;
        if (!body || !name || !email || !postId) {
            throw { status: 400, message: "Faltan campos obligatorios" };
        }
        // Verificar que el post existe y no está eliminado
        const post = await this.postRepository.findOne({ where: { id: postId } });
        if (!post || post.deletedAt) {
            throw { status: 404, message: "Post no encontrado o eliminado" };
        }
        const comment = this.commentRepository.create({
            body,
            name,
            email,
            postId,
        });
        await this.commentRepository.save(comment);
        return comment;
    }
    // Mover un comentario a otro post
    async moveComment(data) {
        const { commentId, newPostId } = data;
        if (!commentId || !newPostId) {
            throw { status: 400, message: "Faltan campos obligatorios" };
        }
        // Verificar que el comentario existe
        const comment = await this.commentRepository.findOne({
            where: { id: commentId },
        });
        if (!comment) {
            throw { status: 404, message: "Comentario no encontrado" };
        }
        // Verificar que el nuevo post existe y no está eliminado
        const newPost = await this.postRepository.findOne({
            where: { id: newPostId },
        });
        if (!newPost || newPost.deletedAt) {
            throw { status: 404, message: "Nuevo post no encontrado o eliminado" };
        }
        // Actualizar el postId del comentario
        comment.postId = newPostId;
        await this.commentRepository.save(comment);
        return comment;
    }
}
exports.CommentService = CommentService;


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/dist/services/index.js

"use strict";
// src/services/index.ts
Object.defineProperty(exports, "__esModule", { value: true });
exports.postService = exports.commentService = void 0;
const comment_service_1 = require("./comment.service");
const post_service_1 = require("./post.service");
exports.commentService = new comment_service_1.CommentService();
exports.postService = new post_service_1.PostService();


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/dist/services/post.service.js

"use strict";
// src/services/post.service.ts
Object.defineProperty(exports, "__esModule", { value: true });
exports.PostService = void 0;
const Post_1 = require("../entities/Post");
const ormconfig_1 = require("../ormconfig");
class PostService {
    constructor() {
        const isTest = process.env.NODE_ENV === "test";
        this.postRepository = isTest
            ? ormconfig_1.testDataSource.getRepository(Post_1.Post)
            : ormconfig_1.dataSource.getRepository(Post_1.Post);
    }
    // Crear un nuevo post
    async createPost(data) {
        const { title, body, image, userId } = data;
        if (!title || !body || !userId) {
            throw { status: 400, message: "Faltan campos obligatorios" };
        }
        const post = this.postRepository.create({ title, body, image, userId });
        await this.postRepository.save(post);
        return post;
    }
    // Obtener todos los posts
    async getAllPosts() {
        return this.postRepository.find({ relations: ["comments"] });
    }
    // Obtener un post por ID
    async getPostById(id) {
        if (isNaN(id)) {
            throw { status: 400, message: "ID inválido" };
        }
        const post = await this.postRepository.findOne({
            where: { id },
            relations: ["comments"],
        });
        if (!post || post.deletedAt) {
            throw { status: 404, message: "Post no encontrado" };
        }
        return post;
    }
    // Obtener comentarios por ID de post
    async getCommentsByPostId(postId) {
        if (isNaN(postId)) {
            throw { status: 400, message: "ID de post inválido" };
        }
        const post = await this.postRepository.findOne({
            where: { id: postId },
            relations: ["comments"],
        });
        if (!post) {
            throw { status: 404, message: "Post no encontrado" };
        }
        return post.comments;
    }
    // Soft delete de un post
    async deletePost(id) {
        if (isNaN(id)) {
            throw { status: 400, message: "ID inválido" };
        }
        const post = await this.postRepository.findOne({ where: { id } });
        if (!post || post.deletedAt) {
            throw { status: 404, message: "Post no encontrado" };
        }
        await this.postRepository.softDelete(id);
    }
    // Restaurar un post soft deleted
    async restorePost(id) {
        if (isNaN(id)) {
            throw { status: 400, message: "ID inválido" };
        }
        const post = await this.postRepository.findOne({
            where: { id },
            withDeleted: true,
        });
        if (!post || !post.deletedAt) {
            throw { status: 404, message: "Post no encontrado o no está eliminado" };
        }
        await this.postRepository.restore(id);
    }
}
exports.PostService = PostService;


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/dist/swagger.config.js

"use strict";
// src/swagger.config.ts
Object.defineProperty(exports, "__esModule", { value: true });
const swaggerOptions = {
    openapi: "3.0.0",
    info: {
        title: "Post Comments API",
        version: "1.0.0",
        description: "API para gestionar posts y comentarios",
    },
    servers: [
        {
            url: "http://localhost:3000",
            description: "Servidor local",
        },
    ],
    components: {
        schemas: {
            Post: {
                type: "object",
                properties: {
                    id: { type: "integer", description: "ID único del post" },
                    title: { type: "string", description: "Título del post" },
                    body: { type: "string", description: "Contenido del post" },
                    image: {
                        type: "string",
                        nullable: true,
                        description: "URL de la imagen del post",
                    },
                    userId: {
                        type: "integer",
                        description: "ID del usuario que creó el post",
                    },
                    comments: {
                        type: "array",
                        items: { $ref: "#/components/schemas/Comment" },
                        description: "Lista de comentarios asociados al post",
                    },
                },
                required: ["id", "title", "body", "userId"],
            },
            Comment: {
                type: "object",
                properties: {
                    id: { type: "integer", description: "ID único del comentario" },
                    body: { type: "string", description: "Contenido del comentario" },
                    name: {
                        type: "string",
                        description: "Nombre del autor del comentario",
                    },
                    email: {
                        type: "string",
                        description: "Email del autor del comentario",
                    },
                    postId: {
                        type: "integer",
                        description: "ID del post al que pertenece el comentario",
                    },
                },
                required: ["id", "body", "name", "email", "postId"],
            },
        },
    },
};
exports.default = swaggerOptions;


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/src/app.ts

// src/app.ts

import express from "express";
import postRoutes from "./routes/post.routes";
import commentRoutes from "./routes/comment.routes";
import testRoutes from "./routes/test.routes"; // Importar la ruta de prueba
import swaggerUi from "swagger-ui-express";
import swaggerJsDoc from "swagger-jsdoc";
import swaggerOptions from "./swagger.config";
import { errorHandler } from "./middleware/errorHandler";

const app = express();

app.use(express.json());

// Configuración de Swagger
const swaggerSpec = swaggerJsDoc({
  definition: swaggerOptions,
  apis: ["src/routes/*.ts"],
});
app.use("/api-docs", swaggerUi.serve, swaggerUi.setup(swaggerSpec));

// Rutas de la API
app.use("/api/posts", postRoutes);
app.use("/api/comments", commentRoutes);
app.use("/api/test", testRoutes); // Usar la ruta de prueba

// Middleware de manejo de errores
app.use(errorHandler);

export default app;


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/src/controllers/comment.controller.ts

// src/controllers/comment.controller.ts
import { Request, Response, NextFunction } from "express";
import { CommentService } from "../services/comment.service";
import { CommentCreateDTO, CommentMoveDTO } from "../dtos/comment.dtos";
import { Comment } from "../entities/Comment";

const commentService: CommentService = new CommentService();

/**
 * Controlador para crear un comentario asociado a un post existente.
 */
export const createComment = async (
  req: Request<unknown, unknown, CommentCreateDTO>,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    const { body, name, email, postId }: CommentCreateDTO = req.body;

    const postIdNumber: number = Number(postId); // Conversion explícita a número

    const savedComment: Comment = await commentService.createComment({
      body,
      name,
      email,
      postId: postIdNumber,
    });

    res.status(201).json(savedComment);
  } catch (error: unknown) {
    next(error);
  }
};

/**
 * Controlador para mover un comentario de un post a otro.
 */
export const moveComment = async (
  req: Request<unknown, unknown, CommentMoveDTO>,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    const { commentId, newPostId }: CommentMoveDTO = req.body;

    const commentIdNumber: number = Number(commentId); // Conversion explícita a número
    const newPostIdNumber: number = Number(newPostId); // Conversion explícita a número

    const movedComment: Comment = await commentService.moveComment({
      commentId: commentIdNumber,
      newPostId: newPostIdNumber,
    });

    res.status(200).json({
      message: "Comentario movido exitosamente",
      comment: movedComment,
    });
  } catch (error: unknown) {
    next(error);
  }
};


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/src/controllers/post.controller.ts

// src/controllers/post.controller.ts
import { Request, Response, NextFunction } from "express";
import { PostService } from "../services/post.service";

const postService = new PostService();

/**
 * Obtiene todos los posts con sus comentarios.
 */
export const getAllPosts = async (
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    const posts = await postService.getAllPosts();
    res.json(posts);
  } catch (error) {
    next(error);
  }
};

/**
 * Crea un nuevo post.
 */
export const createPost = async (
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    const { title, body, image, userId } = req.body;
    const savedPost = await postService.createPost({
      title,
      body,
      image,
      userId,
    });
    res.status(201).json(savedPost);
  } catch (error) {
    next(error);
  }
};

/**
 * Obtiene un post por su ID, incluyendo sus comentarios.
 */
export const getPostById = async (
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    const { id } = req.params;
    const post = await postService.getPostById(Number(id));
    res.json(post);
  } catch (error) {
    next(error);
  }
};

/**
 * Obtiene todos los comentarios de un post específico.
 */
export const getCommentsByPostId = async (
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    const { post_id } = req.params;
    const comments = await postService.getCommentsByPostId(Number(post_id));
    res.json(comments);
  } catch (error) {
    next(error);
  }
};

/**
 * Elimina lógicamente un post por su ID.
 */
export const softDeletePost = async (
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    const { id } = req.params;
    await postService.deletePost(Number(id));
    res.status(200).json({ message: "Post eliminado correctamente" });
  } catch (error) {
    next(error);
  }
};

/**
 * Restaura un post eliminado lógicamente.
 */
export const restorePost = async (
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    const { id } = req.params;
    await postService.restorePost(Number(id));
    res.status(200).json({ message: "Post restaurado correctamente" });
  } catch (error) {
    next(error);
  }
};


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/src/dtos/CreateCommentDTO.ts

// src/dtos/CreateCommentDTO.ts

import { IsInt, IsNotEmpty, IsString, IsEmail } from "class-validator";

export class CreateCommentDTO {
  @IsString()
  @IsNotEmpty()
  body!: string;

  @IsString()
  @IsNotEmpty()
  name!: string;

  @IsEmail()
  email!: string;

  @IsInt()
  postId!: number;
}


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/src/dtos/CreatePostDTO.ts

// src/dtos/post.dtos.ts
export interface CreatePostDTO {
  title: string;
  body: string;
  image: string;
  userId: number;
}


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/src/dtos/comment.dtos.ts

// src/dtos/comment.dtos.ts
export interface CommentCreateDTO {
  body: string;
  name: string;
  email: string;
  postId: string;
}

export interface CommentMoveDTO {
  commentId: string;
  newPostId: string;
}


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/src/entities/Comment.ts

// src/entities/Comment.ts

import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  ManyToOne,
  JoinColumn,
} from "typeorm";
import { Post } from "./Post";

@Entity()
export class Comment {
  @PrimaryGeneratedColumn()
  id!: number;

  @Column({ type: "text" })
  body!: string;

  @Column({ type: "varchar", length: 255 })
  name!: string;

  @Column({ type: "varchar", length: 255 })
  email!: string;

  @Column({ type: "int" })
  postId!: number;

  @ManyToOne(() => Post, (post) => post.comments, { onDelete: "CASCADE" })
  @JoinColumn({ name: "postId" })
  post!: Post;
}


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/src/entities/Post.ts

// src/entities/Post.ts

import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  OneToMany,
  DeleteDateColumn,
} from "typeorm";
import { Comment } from "./Comment";

@Entity()
export class Post {
  @PrimaryGeneratedColumn()
  id!: number;

  @Column({ type: "varchar" })
  title!: string;

  @Column({ type: "text", nullable: true })
  body?: string;

  @Column({ type: "varchar", nullable: true })
  image?: string;

  @Column({ type: "int" })
  userId!: number;

  @OneToMany(() => Comment, (comment) => comment.post, { cascade: true })
  comments!: Comment[];

  @DeleteDateColumn()
  deletedAt?: Date | null; // Maneja soft delete automáticamente
}


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/src/entities/index.ts

// src/entities/index.ts
export * from "./Post";
export * from "./Comment";


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/src/index.ts

// src/index.ts
import dotenv from "dotenv";

// Cargar variables de entorno desde .env
dotenv.config();

import "reflect-metadata";
import { dataSource } from "./ormconfig";
import app from "./app";

const PORT = 3000;

dataSource
  .initialize()
  .then(() => {
    console.log("Data Source has been initialized!");
    app.listen(PORT, () =>
      console.log(`Server is running on http://localhost:${PORT}`)
    );
  })
  .catch((err) => {
    console.error("Error during Data Source initialization", err);
  });


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/src/middleware/errorHandler.ts

// src/middleware/errorHandler.ts

import { Request, Response, NextFunction } from "express";

/**
 * Middleware de manejo de errores.
 * Captura cualquier error que ocurra en las rutas y envía una respuesta estandarizada.
 */
export const errorHandler = (
  err: any,
  req: Request,
  res: Response,
  next: NextFunction
) => {
  console.error(err);

  const statusCode = err.status || err.statusCode || 500;
  const message = err.message || "Internal Server Error";

  res.status(statusCode).json({
    message,
  });
};


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/src/migrations/AddPostIdToComment.ts

// import {
//   MigrationInterface,
//   QueryRunner,
//   TableColumn,
//   TableForeignKey,
// } from "typeorm";

// export class AddPostIdToComment1682579463000 implements MigrationInterface {
//   public async up(queryRunner: QueryRunner): Promise<void> {
//     // Añadir la columna postId a la tabla comment
//     await queryRunner.addColumn(
//       "comment",
//       new TableColumn({
//         name: "postId",
//         type: "int",
//         isNullable: false, // Ajusta según tus necesidades
//       })
//     );

//     // Crear la clave foránea hacia la tabla post
//     await queryRunner.createForeignKey(
//       "comment",
//       new TableForeignKey({
//         columnNames: ["postId"],
//         referencedColumnNames: ["id"],
//         referencedTableName: "post",
//         onDelete: "CASCADE", // Ajusta según tus necesidades
//       })
//     );
//   }

//   public async down(queryRunner: QueryRunner): Promise<void> {
//     // Obtener la tabla comment
//     const table = await queryRunner.getTable("comment");
//     if (!table) {
//       throw new Error("La tabla 'comment' no existe");
//     }

//     // Encontrar la clave foránea creada
//     const foreignKey = table.foreignKeys.find(
//       (fk) => fk.columnNames.indexOf("postId") !== -1
//     );
//     if (foreignKey) {
//       await queryRunner.dropForeignKey("comment", foreignKey);
//     }

//     // Eliminar la columna postId
//     await queryRunner.dropColumn("comment", "postId");
//   }
// }


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/src/ormconfig.ts

// src/ormconfig.ts

import { DataSource } from "typeorm";
import { Post } from "./entities/Post";
import { Comment } from "./entities/Comment";
import dotenv from "dotenv";

dotenv.config();

// Instancia para Desarrollo y Producción
export const dataSource = new DataSource({
  type: "mysql",
  host: process.env.DB_HOST || "localhost",
  port: parseInt(process.env.DB_PORT || "3306"),
  username: process.env.DB_USER || "root",
  password: process.env.DB_PASSWORD || "password",
  database: process.env.DB_NAME || "my_database",
  synchronize: false, // Debe ser false para usar migraciones
  logging: false,
  entities: [Post, Comment],
  migrations: ["src/migrations/*.ts"],
  subscribers: [],
});

// Instancia para Pruebas
export const testDataSource = new DataSource({
  type: "sqlite",
  database: ":memory:",
  dropSchema: true,
  entities: [Post, Comment],
  synchronize: true, // Sincronizar el esquema para pruebas
  logging: false,
});


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/src/routes/comment.routes.ts

// src/routes/comment.routes.ts

import { Router } from "express";
import { createComment, moveComment } from "../controllers/comment.controller";

const router = Router();

/**
 * @swagger
 * /api/comments:
 *   post:
 *     summary: Crea un nuevo comentario
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               body:
 *                 type: string
 *               name:
 *                 type: string
 *               email:
 *                 type: string
 *               postId:
 *                 type: integer
 *             required:
 *               - body
 *               - name
 *               - email
 *               - postId
 *     responses:
 *       201:
 *         description: Comentario creado
 *       400:
 *         description: Faltan campos obligatorios
 *       404:
 *         description: Post no encontrado o eliminado
 *       500:
 *         description: Error interno del servidor
 */
router.post("/", createComment);

/**
 * @swagger
 * /api/comments/move:
 *   put:
 *     summary: Mueve un comentario de un post a otro
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               commentId:
 *                 type: integer
 *                 description: ID del comentario a mover
 *               newPostId:
 *                 type: integer
 *                 description: ID del nuevo post al que se moverá el comentario
 *             required:
 *               - commentId
 *               - newPostId
 *     responses:
 *       200:
 *         description: Comentario movido exitosamente
 *       400:
 *         description: IDs inválidos
 *       404:
 *         description: Comentario o nuevo post no encontrado
 *       500:
 *         description: Error interno del servidor
 */
router.put("/move", moveComment);

export default router;


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/src/routes/post.routes.ts

// src/routes/post.routes.ts

import { Router } from "express";
import {
  getAllPosts,
  createPost,
  getPostById,
  getCommentsByPostId,
  softDeletePost,
  restorePost,
} from "../controllers/post.controller";

const router = Router();

/**
 * @swagger
 * /api/posts:
 *   get:
 *     summary: Obtiene todos los posts
 *     responses:
 *       200:
 *         description: Lista de posts
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 $ref: "#/components/schemas/Post"
 */
router.get("/", getAllPosts);

/**
 * @swagger
 * /api/posts:
 *   post:
 *     summary: Crea un nuevo post
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               title:
 *                 type: string
 *               body:
 *                 type: string
 *               image:
 *                 type: string
 *               userId:
 *                 type: integer
 *             required:
 *               - title
 *               - body
 *               - userId
 *     responses:
 *       201:
 *         description: Post creado
 *       400:
 *         description: Faltan campos obligatorios
 *       500:
 *         description: Error interno del servidor
 */
router.post("/", createPost);

/**
 * @swagger
 * /api/posts/{id}:
 *   get:
 *     summary: Obtiene un post por ID
 *     parameters:
 *       - name: id
 *         in: path
 *         required: true
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: Post encontrado
 *         content:
 *           application/json:
 *             schema:
 *               $ref: "#/components/schemas/Post"
 *       400:
 *         description: ID inválido
 *       404:
 *         description: Post no encontrado
 *       500:
 *         description: Error interno del servidor
 */
router.get("/:id", getPostById);

/**
 * @swagger
 * /api/posts/{post_id}/comments:
 *   get:
 *     summary: Obtiene todos los comentarios de un post específico
 *     parameters:
 *       - name: post_id
 *         in: path
 *         required: true
 *         description: ID del post para obtener sus comentarios
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: Lista de comentarios del post
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 $ref: "#/components/schemas/Comment"
 *       400:
 *         description: ID de post inválido
 *       404:
 *         description: Post no encontrado
 *       500:
 *         description: Error interno del servidor
 */
router.get("/:post_id/comments", getCommentsByPostId);

/**
 * @swagger
 * /api/posts/{id}:
 *   delete:
 *     summary: Elimina lógicamente un post por su ID
 *     parameters:
 *       - name: id
 *         in: path
 *         required: true
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: Post eliminado correctamente
 *       400:
 *         description: ID inválido
 *       404:
 *         description: Post no encontrado
 *       500:
 *         description: Error interno del servidor
 */
router.delete("/:id", softDeletePost);

/**
 * @swagger
 * /api/posts/{id}/restore:
 *   patch:
 *     summary: Restaura un post eliminado lógicamente
 *     parameters:
 *       - name: id
 *         in: path
 *         required: true
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: Post restaurado correctamente
 *       400:
 *         description: ID inválido
 *       404:
 *         description: Post no encontrado o no está eliminado
 *       500:
 *         description: Error interno del servidor
 */
router.patch("/:id/restore", restorePost);

export default router;


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/src/routes/test.routes.ts

// src/routes/test.routes.ts

import { Router, Request, Response } from "express";

const router = Router();

/**
 * Ruta de prueba para generar un error.
 */
router.get("/error", (req: Request, res: Response) => {
  throw new Error("This is a test error.");
});

export default router;


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/src/services/comment.service.ts

// src/services/comment.service.ts

import { Repository } from "typeorm";
import { Comment } from "../entities/Comment";
import { dataSource, testDataSource } from "../ormconfig";
import { Post } from "../entities/Post";

interface CreateCommentDTO {
  body: string;
  name: string;
  email: string;
  postId: number;
}

interface MoveCommentDTO {
  commentId: number;
  newPostId: number;
}

export class CommentService {
  private commentRepository: Repository<Comment>;
  private postRepository: Repository<Post>;

  constructor() {
    const isTest = process.env.NODE_ENV === "test";
    this.commentRepository = isTest
      ? testDataSource.getRepository(Comment)
      : dataSource.getRepository(Comment);
    this.postRepository = isTest
      ? testDataSource.getRepository(Post)
      : dataSource.getRepository(Post);
  }

  // Crear un nuevo comentario
  async createComment(data: CreateCommentDTO): Promise<Comment> {
    const { body, name, email, postId } = data;

    if (!body || !name || !email || !postId) {
      throw { status: 400, message: "Faltan campos obligatorios" };
    }

    // Verificar que el post existe y no está eliminado
    const post = await this.postRepository.findOne({ where: { id: postId } });
    if (!post || post.deletedAt) {
      throw { status: 404, message: "Post no encontrado o eliminado" };
    }

    const comment = this.commentRepository.create({
      body,
      name,
      email,
      postId,
    });
    await this.commentRepository.save(comment);
    return comment;
  }

  // Mover un comentario a otro post
  async moveComment(data: MoveCommentDTO): Promise<Comment> {
    const { commentId, newPostId } = data;

    if (!commentId || !newPostId) {
      throw { status: 400, message: "Faltan campos obligatorios" };
    }

    // Verificar que el comentario existe
    const comment = await this.commentRepository.findOne({
      where: { id: commentId },
    });
    if (!comment) {
      throw { status: 404, message: "Comentario no encontrado" };
    }

    // Verificar que el nuevo post existe y no está eliminado
    const newPost = await this.postRepository.findOne({
      where: { id: newPostId },
    });
    if (!newPost || newPost.deletedAt) {
      throw { status: 404, message: "Nuevo post no encontrado o eliminado" };
    }

    // Actualizar el postId del comentario
    comment.postId = newPostId;
    await this.commentRepository.save(comment);

    return comment;
  }
}


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/src/services/index.ts

// src/services/index.ts

import { CommentService } from "./comment.service";
import { PostService } from "./post.service";

export const commentService = new CommentService();
export const postService = new PostService();


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/src/services/post.service.ts

// src/services/post.service.ts

import { Repository } from "typeorm";
import { Post } from "../entities/Post";
import { dataSource, testDataSource } from "../ormconfig";
import { Comment } from "../entities/Comment";

interface CreatePostDTO {
  title: string;
  body: string;
  image?: string;
  userId: number;
}

export class PostService {
  private postRepository: Repository<Post>;

  constructor() {
    const isTest = process.env.NODE_ENV === "test";
    this.postRepository = isTest
      ? testDataSource.getRepository(Post)
      : dataSource.getRepository(Post);
  }

  // Crear un nuevo post
  async createPost(data: CreatePostDTO): Promise<Post> {
    const { title, body, image, userId } = data;

    if (!title || !body || !userId) {
      throw { status: 400, message: "Faltan campos obligatorios" };
    }

    const post = this.postRepository.create({ title, body, image, userId });
    await this.postRepository.save(post);
    return post;
  }

  // Obtener todos los posts
  async getAllPosts(): Promise<Post[]> {
    return this.postRepository.find({ relations: ["comments"] });
  }

  // Obtener un post por ID
  async getPostById(id: number): Promise<Post> {
    if (isNaN(id)) {
      throw { status: 400, message: "ID inválido" };
    }

    const post = await this.postRepository.findOne({
      where: { id },
      relations: ["comments"],
    });

    if (!post || post.deletedAt) {
      throw { status: 404, message: "Post no encontrado" };
    }

    return post;
  }

  // Obtener comentarios por ID de post
  async getCommentsByPostId(postId: number): Promise<Comment[]> {
    if (isNaN(postId)) {
      throw { status: 400, message: "ID de post inválido" };
    }

    const post = await this.postRepository.findOne({
      where: { id: postId },
      relations: ["comments"],
    });

    if (!post) {
      throw { status: 404, message: "Post no encontrado" };
    }

    return post.comments;
  }

  // Soft delete de un post
  async deletePost(id: number): Promise<void> {
    if (isNaN(id)) {
      throw { status: 400, message: "ID inválido" };
    }

    const post = await this.postRepository.findOne({ where: { id } });

    if (!post || post.deletedAt) {
      throw { status: 404, message: "Post no encontrado" };
    }

    await this.postRepository.softDelete(id);
  }

  // Restaurar un post soft deleted
  async restorePost(id: number): Promise<void> {
    if (isNaN(id)) {
      throw { status: 400, message: "ID inválido" };
    }

    const post = await this.postRepository.findOne({
      where: { id },
      withDeleted: true,
    });

    if (!post || !post.deletedAt) {
      throw { status: 404, message: "Post no encontrado o no está eliminado" };
    }

    await this.postRepository.restore(id);
  }
}


/********************/

