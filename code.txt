
/Users/matiaskochman/dev/personal/tests/post_comments/.env

DB_HOST=localhost
DB_PORT=5555
DB_USER=my_user
DB_PASSWORD=my_password
DB_NAME=my_database


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/src/swagger.config.ts

// src/swagger.config.ts

const swaggerOptions = {
  openapi: "3.0.0",
  info: {
    title: "Post Comments API",
    version: "1.0.0",
    description: "API para gestionar posts y comentarios",
  },
  servers: [
    {
      url: "http://localhost:3000",
      description: "Servidor local",
    },
  ],
  components: {
    schemas: {
      Post: {
        type: "object",
        properties: {
          id: { type: "integer", description: "ID único del post" },
          title: { type: "string", description: "Título del post" },
          body: { type: "string", description: "Contenido del post" },
          image: {
            type: "string",
            nullable: true,
            description: "URL de la imagen del post",
          },
          userId: {
            type: "integer",
            description: "ID del usuario que creó el post",
          },
          comments: {
            type: "array",
            items: { $ref: "#/components/schemas/Comment" },
            description: "Lista de comentarios asociados al post",
          },
        },
        required: ["id", "title", "body", "userId"],
      },
      Comment: {
        type: "object",
        properties: {
          id: { type: "integer", description: "ID único del comentario" },
          body: { type: "string", description: "Contenido del comentario" },
          name: {
            type: "string",
            description: "Nombre del autor del comentario",
          },
          email: {
            type: "string",
            description: "Email del autor del comentario",
          },
          postId: {
            type: "integer",
            description: "ID del post al que pertenece el comentario",
          },
        },
        required: ["id", "body", "name", "email", "postId"],
      },
    },
  },
};

export default swaggerOptions;


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/dist/app.js

"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const express_1 = __importDefault(require("express"));
const post_routes_js_1 = __importDefault(require("./routes/post.routes.js"));
const comment_routes_js_1 = __importDefault(require("./routes/comment.routes.js"));
const swagger_ui_express_1 = __importDefault(require("swagger-ui-express"));
const swagger_jsdoc_1 = __importDefault(require("swagger-jsdoc"));
const swagger_config_js_1 = __importDefault(require("./swagger.config.js"));
const app = (0, express_1.default)();
app.use(express_1.default.json());
// Configuración de Swagger
const swaggerSpec = (0, swagger_jsdoc_1.default)({
    definition: swagger_config_js_1.default,
    apis: ["./src/routes/*.ts"],
});
app.use("/api-docs", swagger_ui_express_1.default.serve, swagger_ui_express_1.default.setup(swaggerSpec));
app.use("/api/posts", post_routes_js_1.default);
app.use("/api/comments", comment_routes_js_1.default);
exports.default = app;


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/dist/controllers/comment.controller.js

"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createComment = void 0;
const ormconfig_js_1 = require("../ormconfig.js");
const Comment_js_1 = require("../entities/Comment.js");
const commentRepository = ormconfig_js_1.AppDataSource.getRepository(Comment_js_1.Comment);
/**
 * Crea un nuevo comentario asociado a un post existente.
 */
const createComment = (req, res) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const { body, name, email, postId } = req.body;
        // Validación de campos obligatorios
        if (!body || !name || !email || !postId) {
            res.status(400).json({ message: "Faltan campos obligatorios" });
            return;
        }
        // Crear el comentario
        const comment = commentRepository.create({
            body,
            name,
            email,
            post: { id: postId },
        });
        // Guardar el comentario en la base de datos
        const savedComment = yield commentRepository.save(comment);
        res.status(201).json(savedComment);
    }
    catch (error) {
        console.error("Error al crear el comentario:", error);
        res.status(500).json({ message: "Error al crear el comentario" });
    }
});
exports.createComment = createComment;


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/dist/controllers/post.controller.js

"use strict";
// src/controllers/post.controller.ts
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCommentsByPostId = exports.getPostById = exports.createPost = exports.getAllPosts = void 0;
const ormconfig_js_1 = require("../ormconfig.js");
const Post_js_1 = require("../entities/Post.js");
const Comment_js_1 = require("../entities/Comment.js");
const postRepository = ormconfig_js_1.AppDataSource.getRepository(Post_js_1.Post);
const commentRepository = ormconfig_js_1.AppDataSource.getRepository(Comment_js_1.Comment);
/**
 * Obtiene todos los posts con sus comentarios.
 */
const getAllPosts = (req, res) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const posts = yield postRepository.find({ relations: ["comments"] });
        res.json(posts);
    }
    catch (error) {
        console.error("Error al obtener los posts:", error);
        res.status(500).json({ message: "Error al obtener los posts" });
    }
});
exports.getAllPosts = getAllPosts;
/**
 * Crea un nuevo post con la posibilidad de incluir comentarios.
 */
const createPost = (req, res) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const { title, body, image, userId, comments } = req.body;
        if (!title || !body || !userId) {
            res.status(400).json({ message: "Faltan campos obligatorios" });
            return;
        }
        const post = postRepository.create({
            title,
            body,
            image,
            userId,
            comments,
        });
        const savedPost = yield postRepository.save(post);
        res.status(201).json(savedPost);
    }
    catch (error) {
        console.error("Error al crear el post:", error);
        res.status(500).json({ message: "Error al crear el post" });
    }
});
exports.createPost = createPost;
/**
 * Obtiene un post por su ID, incluyendo sus comentarios.
 */
const getPostById = (req, res) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const { id } = req.params;
        if (!id || isNaN(Number(id))) {
            res.status(400).json({ message: "ID inválido" });
            return;
        }
        const post = yield postRepository.findOne({
            where: { id: Number(id) },
            relations: ["comments"],
        });
        if (!post) {
            res.status(404).json({ message: "Post no encontrado" });
            return;
        }
        res.json(post);
    }
    catch (error) {
        console.error("Error al obtener el post:", error);
        res.status(500).json({ message: "Error al obtener el post" });
    }
});
exports.getPostById = getPostById;
/**
 * Obtiene todos los comentarios de un post específico.
 */
const getCommentsByPostId = (req, res) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const { post_id } = req.params;
        if (!post_id || isNaN(Number(post_id))) {
            res.status(400).json({ message: "ID de post inválido" });
            return;
        }
        const post = yield postRepository.findOne({
            where: { id: Number(post_id) },
            relations: ["comments"],
        });
        if (!post) {
            res.status(404).json({ message: "Post no encontrado" });
            return;
        }
        res.json(post.comments);
    }
    catch (error) {
        console.error("Error al obtener los comentarios del post:", error);
        res
            .status(500)
            .json({ message: "Error al obtener los comentarios del post" });
    }
});
exports.getCommentsByPostId = getCommentsByPostId;


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/dist/entities/Comment.js

"use strict";
// src/entities/Comment.ts
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Comment = void 0;
const typeorm_1 = require("typeorm");
const Post_js_1 = require("./Post.js");
let Comment = class Comment {
};
exports.Comment = Comment;
__decorate([
    (0, typeorm_1.PrimaryGeneratedColumn)(),
    __metadata("design:type", Number)
], Comment.prototype, "id", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: "text" }),
    __metadata("design:type", String)
], Comment.prototype, "body", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: "varchar", length: 255 }),
    __metadata("design:type", String)
], Comment.prototype, "name", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: "varchar", length: 255 }),
    __metadata("design:type", String)
], Comment.prototype, "email", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: "int" }),
    __metadata("design:type", Number)
], Comment.prototype, "postId", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)(() => Post_js_1.Post, (post) => post.comments, { onDelete: "CASCADE" }),
    (0, typeorm_1.JoinColumn)({ name: "postId" }),
    __metadata("design:type", Post_js_1.Post)
], Comment.prototype, "post", void 0);
exports.Comment = Comment = __decorate([
    (0, typeorm_1.Entity)()
], Comment);


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/dist/entities/Post.js

"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Post = void 0;
// src/entities/Post.ts
const typeorm_1 = require("typeorm");
const Comment_1 = require("./Comment");
let Post = class Post {
};
exports.Post = Post;
__decorate([
    (0, typeorm_1.PrimaryGeneratedColumn)(),
    __metadata("design:type", Number)
], Post.prototype, "id", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: "varchar" }),
    __metadata("design:type", String)
], Post.prototype, "title", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: "text", nullable: true }),
    __metadata("design:type", String)
], Post.prototype, "body", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: "varchar", nullable: true }),
    __metadata("design:type", String)
], Post.prototype, "image", void 0);
__decorate([
    (0, typeorm_1.Column)({ type: "int" }),
    __metadata("design:type", Number)
], Post.prototype, "userId", void 0);
__decorate([
    (0, typeorm_1.OneToMany)(() => Comment_1.Comment, (comment) => comment.post, { cascade: true }),
    __metadata("design:type", Array)
], Post.prototype, "comments", void 0);
exports.Post = Post = __decorate([
    (0, typeorm_1.Entity)()
], Post);


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/dist/index.js

"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// src/index.ts
const dotenv_1 = __importDefault(require("dotenv"));
// Cargar variables de entorno desde .env
dotenv_1.default.config();
require("reflect-metadata");
const ormconfig_1 = require("./ormconfig");
const app_1 = __importDefault(require("./app"));
const PORT = 3000;
ormconfig_1.AppDataSource.initialize()
    .then(() => {
    console.log("Data Source has been initialized!");
    app_1.default.listen(PORT, () => console.log(`Server is running on http://localhost:${PORT}`));
})
    .catch((err) => {
    console.error("Error during Data Source initialization", err);
});


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/dist/migrations/AddPostIdToComment.js

"use strict";
// import {
//   MigrationInterface,
//   QueryRunner,
//   TableColumn,
//   TableForeignKey,
// } from "typeorm";
// export class AddPostIdToComment1682579463000 implements MigrationInterface {
//   public async up(queryRunner: QueryRunner): Promise<void> {
//     // Añadir la columna postId a la tabla comment
//     await queryRunner.addColumn(
//       "comment",
//       new TableColumn({
//         name: "postId",
//         type: "int",
//         isNullable: false, // Ajusta según tus necesidades
//       })
//     );
//     // Crear la clave foránea hacia la tabla post
//     await queryRunner.createForeignKey(
//       "comment",
//       new TableForeignKey({
//         columnNames: ["postId"],
//         referencedColumnNames: ["id"],
//         referencedTableName: "post",
//         onDelete: "CASCADE", // Ajusta según tus necesidades
//       })
//     );
//   }
//   public async down(queryRunner: QueryRunner): Promise<void> {
//     // Obtener la tabla comment
//     const table = await queryRunner.getTable("comment");
//     if (!table) {
//       throw new Error("La tabla 'comment' no existe");
//     }
//     // Encontrar la clave foránea creada
//     const foreignKey = table.foreignKeys.find(
//       (fk) => fk.columnNames.indexOf("postId") !== -1
//     );
//     if (foreignKey) {
//       await queryRunner.dropForeignKey("comment", foreignKey);
//     }
//     // Eliminar la columna postId
//     await queryRunner.dropColumn("comment", "postId");
//   }
// }


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/dist/ormconfig.js

"use strict";
// src/ormconfig.ts
Object.defineProperty(exports, "__esModule", { value: true });
exports.AppDataSource = void 0;
const typeorm_1 = require("typeorm");
const Post_js_1 = require("./entities/Post.js");
const Comment_js_1 = require("./entities/Comment.js");
exports.AppDataSource = new typeorm_1.DataSource({
    type: "mysql",
    host: process.env.DB_HOST || "localhost",
    port: parseInt(process.env.DB_PORT || "5555"),
    username: process.env.DB_USER || "root",
    password: process.env.DB_PASSWORD || "password",
    database: process.env.DB_NAME || "my_database",
    synchronize: true, // Importante para usar migraciones
    logging: true,
    entities: [Post_js_1.Post, Comment_js_1.Comment],
    migrations: ["src/migrations/*.ts"], // Ruta para las migraciones
    subscribers: [],
});


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/dist/routes/comment.routes.js

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const express_1 = require("express");
const comment_controller_js_1 = require("../controllers/comment.controller.js");
const router = (0, express_1.Router)();
router.post("/", comment_controller_js_1.createComment);
exports.default = router;


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/dist/routes/post.routes.js

"use strict";
// src/routes/post.routes.ts
Object.defineProperty(exports, "__esModule", { value: true });
const express_1 = require("express");
const post_controller_js_1 = require("../controllers/post.controller.js");
const router = (0, express_1.Router)();
/**
 * @swagger
 * /api/posts:
 *   get:
 *     summary: Obtiene todos los posts
 *     responses:
 *       200:
 *         description: Lista de posts
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 $ref: "#/components/schemas/Post"
 */
router.get("/", post_controller_js_1.getAllPosts);
/**
 * @swagger
 * /api/posts:
 *   post:
 *     summary: Crea un nuevo post
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: "#/components/schemas/Post"
 *     responses:
 *       201:
 *         description: Post creado
 */
router.post("/", post_controller_js_1.createPost);
/**
 * @swagger
 * /api/posts/{id}:
 *   get:
 *     summary: Obtiene un post por ID
 *     parameters:
 *       - name: id
 *         in: path
 *         required: true
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: Post encontrado
 *         content:
 *           application/json:
 *             schema:
 *               $ref: "#/components/schemas/Post"
 */
router.get("/:id", post_controller_js_1.getPostById);
/**
 * @swagger
 * /api/posts/{post_id}/comments:
 *   get:
 *     summary: Obtiene todos los comentarios de un post específico
 *     parameters:
 *       - name: post_id
 *         in: path
 *         required: true
 *         description: ID del post para obtener sus comentarios
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: Lista de comentarios del post
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 $ref: "#/components/schemas/Comment"
 *       400:
 *         description: ID de post inválido
 *       404:
 *         description: Post no encontrado
 */
router.get("/:post_id/comments", post_controller_js_1.getCommentsByPostId);
exports.default = router;


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/dist/swagger.config.js

"use strict";
// src/swagger.config.ts
Object.defineProperty(exports, "__esModule", { value: true });
const swaggerOptions = {
    openapi: "3.0.0",
    info: {
        title: "Post Comments API",
        version: "1.0.0",
        description: "API para gestionar posts y comentarios",
    },
    servers: [
        {
            url: "http://localhost:3000",
            description: "Servidor local",
        },
    ],
    components: {
        schemas: {
            Post: {
                type: "object",
                properties: {
                    id: { type: "integer", description: "ID único del post" },
                    title: { type: "string", description: "Título del post" },
                    body: { type: "string", description: "Contenido del post" },
                    image: {
                        type: "string",
                        nullable: true,
                        description: "URL de la imagen del post",
                    },
                    userId: {
                        type: "integer",
                        description: "ID del usuario que creó el post",
                    },
                    comments: {
                        type: "array",
                        items: { $ref: "#/components/schemas/Comment" },
                        description: "Lista de comentarios asociados al post",
                    },
                },
                required: ["id", "title", "body", "userId"],
            },
            Comment: {
                type: "object",
                properties: {
                    id: { type: "integer", description: "ID único del comentario" },
                    body: { type: "string", description: "Contenido del comentario" },
                    name: {
                        type: "string",
                        description: "Nombre del autor del comentario",
                    },
                    email: {
                        type: "string",
                        description: "Email del autor del comentario",
                    },
                    postId: {
                        type: "integer",
                        description: "ID del post al que pertenece el comentario",
                    },
                },
                required: ["id", "body", "name", "email", "postId"],
            },
        },
    },
};
exports.default = swaggerOptions;


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/src/app.ts

import express from "express";
import postRoutes from "./routes/post.routes.js";
import commentRoutes from "./routes/comment.routes.js";
import swaggerUi from "swagger-ui-express";
import swaggerJsDoc from "swagger-jsdoc";
import swaggerOptions from "./swagger.config.js";

const app = express();

app.use(express.json());

// Configuración de Swagger
const swaggerSpec = swaggerJsDoc({
  definition: swaggerOptions,
  apis: ["./src/routes/*.ts"],
});
app.use("/api-docs", swaggerUi.serve, swaggerUi.setup(swaggerSpec));

app.use("/api/posts", postRoutes);
app.use("/api/comments", commentRoutes);

export default app;


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/src/controllers/comment.controller.ts

import { Request, Response } from "express";
import { AppDataSource } from "../ormconfig.js";
import { Comment } from "../entities/Comment.js";

const commentRepository = AppDataSource.getRepository(Comment);

/**
 * Crea un nuevo comentario asociado a un post existente.
 */
export const createComment = async (
  req: Request,
  res: Response
): Promise<void> => {
  try {
    const { body, name, email, postId } = req.body;

    // Validación de campos obligatorios
    if (!body || !name || !email || !postId) {
      res.status(400).json({ message: "Faltan campos obligatorios" });
      return;
    }

    // Crear el comentario
    const comment = commentRepository.create({
      body,
      name,
      email,
      post: { id: postId },
    });

    // Guardar el comentario en la base de datos
    const savedComment = await commentRepository.save(comment);

    res.status(201).json(savedComment);
  } catch (error) {
    console.error("Error al crear el comentario:", error);
    res.status(500).json({ message: "Error al crear el comentario" });
  }
};


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/src/controllers/post.controller.ts

// src/controllers/post.controller.ts

import { Request, Response } from "express";
import { AppDataSource } from "../ormconfig.js";
import { Post } from "../entities/Post.js";
import { Comment } from "../entities/Comment.js";

const postRepository = AppDataSource.getRepository(Post);
const commentRepository = AppDataSource.getRepository(Comment);

/**
 * Obtiene todos los posts con sus comentarios.
 */
export const getAllPosts = async (
  req: Request,
  res: Response
): Promise<void> => {
  try {
    const posts = await postRepository.find({ relations: ["comments"] });
    res.json(posts);
  } catch (error) {
    console.error("Error al obtener los posts:", error);
    res.status(500).json({ message: "Error al obtener los posts" });
  }
};

/**
 * Crea un nuevo post con la posibilidad de incluir comentarios.
 */
export const createPost = async (
  req: Request,
  res: Response
): Promise<void> => {
  try {
    const { title, body, image, userId, comments } = req.body;

    if (!title || !body || !userId) {
      res.status(400).json({ message: "Faltan campos obligatorios" });
      return;
    }

    const post = postRepository.create({
      title,
      body,
      image,
      userId,
      comments,
    });
    const savedPost = await postRepository.save(post);
    res.status(201).json(savedPost);
  } catch (error) {
    console.error("Error al crear el post:", error);
    res.status(500).json({ message: "Error al crear el post" });
  }
};

/**
 * Obtiene un post por su ID, incluyendo sus comentarios.
 */
export const getPostById = async (
  req: Request,
  res: Response
): Promise<void> => {
  try {
    const { id } = req.params;

    if (!id || isNaN(Number(id))) {
      res.status(400).json({ message: "ID inválido" });
      return;
    }

    const post = await postRepository.findOne({
      where: { id: Number(id) },
      relations: ["comments"],
    });

    if (!post) {
      res.status(404).json({ message: "Post no encontrado" });
      return;
    }

    res.json(post);
  } catch (error) {
    console.error("Error al obtener el post:", error);
    res.status(500).json({ message: "Error al obtener el post" });
  }
};

/**
 * Obtiene todos los comentarios de un post específico.
 */
export const getCommentsByPostId = async (
  req: Request,
  res: Response
): Promise<void> => {
  try {
    const { post_id } = req.params;

    if (!post_id || isNaN(Number(post_id))) {
      res.status(400).json({ message: "ID de post inválido" });
      return;
    }

    const post = await postRepository.findOne({
      where: { id: Number(post_id) },
      relations: ["comments"],
    });

    if (!post) {
      res.status(404).json({ message: "Post no encontrado" });
      return;
    }

    res.json(post.comments);
  } catch (error) {
    console.error("Error al obtener los comentarios del post:", error);
    res
      .status(500)
      .json({ message: "Error al obtener los comentarios del post" });
  }
};


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/src/entities/Comment.ts

// src/entities/Comment.ts

import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  ManyToOne,
  JoinColumn,
} from "typeorm";
import { Post } from "./Post.js";

@Entity()
export class Comment {
  @PrimaryGeneratedColumn()
  id!: number;

  @Column({ type: "text" })
  body!: string;

  @Column({ type: "varchar", length: 255 })
  name!: string;

  @Column({ type: "varchar", length: 255 })
  email!: string;

  @Column({ type: "int" })
  postId!: number;

  @ManyToOne(() => Post, (post) => post.comments, { onDelete: "CASCADE" })
  @JoinColumn({ name: "postId" })
  post!: Post;
}


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/src/entities/Post.ts

// src/entities/Post.ts
import { Entity, PrimaryGeneratedColumn, Column, OneToMany } from "typeorm";
import { Comment } from "./Comment";

@Entity()
export class Post {
  @PrimaryGeneratedColumn()
  id!: number;

  @Column({ type: "varchar" })
  title!: string;

  @Column({ type: "text", nullable: true })
  body?: string;

  @Column({ type: "varchar", nullable: true })
  image?: string;

  @Column({ type: "int" })
  userId!: number;

  @OneToMany(() => Comment, (comment) => comment.post, { cascade: true })
  comments!: Comment[];
}


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/src/index.ts

// src/index.ts
import dotenv from "dotenv";

// Cargar variables de entorno desde .env
dotenv.config();

import "reflect-metadata";
import { AppDataSource } from "./ormconfig";
import app from "./app";

const PORT = 3000;

AppDataSource.initialize()
  .then(() => {
    console.log("Data Source has been initialized!");
    app.listen(PORT, () =>
      console.log(`Server is running on http://localhost:${PORT}`)
    );
  })
  .catch((err) => {
    console.error("Error during Data Source initialization", err);
  });


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/src/migrations/AddPostIdToComment.ts

// import {
//   MigrationInterface,
//   QueryRunner,
//   TableColumn,
//   TableForeignKey,
// } from "typeorm";

// export class AddPostIdToComment1682579463000 implements MigrationInterface {
//   public async up(queryRunner: QueryRunner): Promise<void> {
//     // Añadir la columna postId a la tabla comment
//     await queryRunner.addColumn(
//       "comment",
//       new TableColumn({
//         name: "postId",
//         type: "int",
//         isNullable: false, // Ajusta según tus necesidades
//       })
//     );

//     // Crear la clave foránea hacia la tabla post
//     await queryRunner.createForeignKey(
//       "comment",
//       new TableForeignKey({
//         columnNames: ["postId"],
//         referencedColumnNames: ["id"],
//         referencedTableName: "post",
//         onDelete: "CASCADE", // Ajusta según tus necesidades
//       })
//     );
//   }

//   public async down(queryRunner: QueryRunner): Promise<void> {
//     // Obtener la tabla comment
//     const table = await queryRunner.getTable("comment");
//     if (!table) {
//       throw new Error("La tabla 'comment' no existe");
//     }

//     // Encontrar la clave foránea creada
//     const foreignKey = table.foreignKeys.find(
//       (fk) => fk.columnNames.indexOf("postId") !== -1
//     );
//     if (foreignKey) {
//       await queryRunner.dropForeignKey("comment", foreignKey);
//     }

//     // Eliminar la columna postId
//     await queryRunner.dropColumn("comment", "postId");
//   }
// }


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/src/ormconfig.ts

// src/ormconfig.ts

import { DataSource } from "typeorm";
import { Post } from "./entities/Post.js";
import { Comment } from "./entities/Comment.js";

export const AppDataSource = new DataSource({
  type: "mysql",
  host: process.env.DB_HOST || "localhost",
  port: parseInt(process.env.DB_PORT || "5555"),
  username: process.env.DB_USER || "root",
  password: process.env.DB_PASSWORD || "password",
  database: process.env.DB_NAME || "my_database",
  synchronize: true, // Importante para usar migraciones
  logging: true,
  entities: [Post, Comment],
  migrations: ["src/migrations/*.ts"], // Ruta para las migraciones
  subscribers: [],
});


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/src/routes/comment.routes.ts

import { Router } from "express";
import { createComment } from "../controllers/comment.controller.js";

const router = Router();

router.post("/", createComment);

export default router;


/********************/


/Users/matiaskochman/dev/personal/tests/post_comments/src/routes/post.routes.ts

// src/routes/post.routes.ts

import { Router } from "express";
import {
  getAllPosts,
  createPost,
  getPostById,
  getCommentsByPostId,
} from "../controllers/post.controller.js";

const router = Router();

/**
 * @swagger
 * /api/posts:
 *   get:
 *     summary: Obtiene todos los posts
 *     responses:
 *       200:
 *         description: Lista de posts
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 $ref: "#/components/schemas/Post"
 */
router.get("/", getAllPosts);

/**
 * @swagger
 * /api/posts:
 *   post:
 *     summary: Crea un nuevo post
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: "#/components/schemas/Post"
 *     responses:
 *       201:
 *         description: Post creado
 */
router.post("/", createPost);

/**
 * @swagger
 * /api/posts/{id}:
 *   get:
 *     summary: Obtiene un post por ID
 *     parameters:
 *       - name: id
 *         in: path
 *         required: true
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: Post encontrado
 *         content:
 *           application/json:
 *             schema:
 *               $ref: "#/components/schemas/Post"
 */
router.get("/:id", getPostById);

/**
 * @swagger
 * /api/posts/{post_id}/comments:
 *   get:
 *     summary: Obtiene todos los comentarios de un post específico
 *     parameters:
 *       - name: post_id
 *         in: path
 *         required: true
 *         description: ID del post para obtener sus comentarios
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: Lista de comentarios del post
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 $ref: "#/components/schemas/Comment"
 *       400:
 *         description: ID de post inválido
 *       404:
 *         description: Post no encontrado
 */
router.get("/:post_id/comments", getCommentsByPostId);

export default router;


/********************/

